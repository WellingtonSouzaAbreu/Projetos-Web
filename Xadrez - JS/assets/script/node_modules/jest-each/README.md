<div align="center">
  <h1>jest-each</h1>
  Jest Parameterised Testing
</div>

<hr />

[![version](https://img.shields.io/npm/v/jest-each.svg?style=flat-square)](https://www.npmjs.com/package/jest-each) [![downloads](https://img.shields.io/npm/dm/jest-each.svg?style=flat-square)](http://npm-stat.com/charts.html?package=jest-each&from=2017-03-21) [![MIT License](https://img.shields.io/npm/l/jest-each.svg?style=flat-square)](https://github.com/facebook/jest/blob/master/LICENSE)

A parameterised testing library for [Jest](https://jestjs.io/) inspired by [mocha-each](https://github.com/ryym/mocha-each).

jest-each allows you to provide multiple arguments to your `test`/`describe` which results in the test/suite being run once per row of parameters.

## Features

- `.test` to runs multiple tests with parameterised data
  - Also under the alias: `.it`
- `.test.only` to only run the parameterised tests
  - Also under the aliases: `.it.only` or `.fit`
- `.test.skip` to skip the parameterised tests
  - Also under the aliases: `.it.skip` or `.xit` or `.xtest`
- `.test.concurrent`
  - Also under the alias: `.it.concurrent`
- `.test.concurrent.only`
  - Also under the alias: `.it.concurrent.only`
- `.test.concurrent.skip`
  - Also under the alias: `.it.concurrent.skip`
- `.describe` to runs test suites with parameterised data
- `.describe.only` to only run the parameterised suite of tests
  - Also under the aliases: `.fdescribe`
- `.describe.skip` to skip the parameterised suite of tests
  - Also under the aliases: `.xdescribe`
- Asynchronous tests with `done`
- Unique test titles with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):
  - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).
  - `%s`- String.
  - `%d`- Number.
  - `%i` - Integer.
  - `%f` - Floating point value.
  - `%j` - JSON.
  - `%o` - Object.
  - `%#` - Index of the test case.
  - `%%` - single percent sign ('%'). This does not consume an argument.
- ğŸ–– Spock like data tables with [Tagged Template Literals](#tagged-template-literal-of-rows)

---

- [Demo](#demo)
- [Installation](#installation)
- [Importing](#importing)
- APIs
  - [Array of Rows](#array-of-rows)
    - [Usage](#usage)
  - [Tagged Template Literal of rows](#tagged-template-literal-of-rows)
    - [Usage](#usage-1)

## Demo

#### Tests without jest-each

![Current jest tests](assets/default-demo.gif)

#### Tests can be re-written with jest-each to:

**`.test`**

![Current jest tests](assets/test-demo.gif)

**`.test` with Tagged Template Literals**

![Current jest tests](assets/tagged-template-literal.gif)

**`.describe`**

![Current jest tests](assets/describe-demo.gif)

## Installation

`npm i --save-dev jest-each`

`yarn add -D jest-each`

## Importing

jest-each is a default export so it can be imported with whatever name you like.

```js
// es6
import each from 'jest-each';
```

```js
// es5
const each = require('jest-each').default;
```

## Array of rows

### API

#### `each([parameters]).test(name, testFn)`

##### `each`:

- parameters: `Array` of Arrays with the arguments that are passed into the `testFn` for each row
  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`

##### `.test`:

- name: `String` the title of the `test`.
  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):
    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).
    - `%s`- String.
    - `%d`- Number.
    - `%i` - Integer.
    - `%f` - Floating point value.
    - `%j` - JSON.
    - `%o` - Object.
    - `%#` - Index of the test case.
    - `%%` - single percent sign ('%'). This does not consume an argument.
- testFn: `Function` the test logic, this is the function that will receive the parameters of each row as function arguments

#### `each([parameters]).describe(name, suiteFn)`

##### `each`:

- parameters: `Array` of Arrays with the arguments that are passed into the `suiteFn` for each row
  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`

##### `.describe`:

- name: `String` the title of the `describe`
  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):
    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).
    - `%s`- String.
    - `%d`- Number.
    - `%i` - Integer.
    - `%f` - Floating point value.
    - `%j` - JSON.
    - `%o` - Object.
    - `%#` - Index of the test case.
    - `%%` - single percent sign ('%'). This does not consume an argument.
- suiteFn: `Function` the suite of `test`/`it`s to be ran, this is the function that will receive the parameters in each row as function arguments

### Usage

#### `.test(name, fn)`

Alias: `.it(name, fn)`

```js
each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
]).test('returns the result of adding %d to %d', (a, b, expected) => {
  expect(a + b).toBe(expected);
});
```

#### `.test.only(name, fn)`

Aliases: `.it.only(name, fn)` or `.fit(name, fn)`

```js
each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
]).test.only('returns the result of adding %d to %d', (a, b, expected) => {
  expect(a + b).toBe(expected);
});
```

#### `.test.skip(name, fn)`

Aliases: `.it.skip(name, fn)` or `.xit(name, fn)` or `.xtest(name, fn)`

```js
each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
]).test.skip('returns the result of adding %d to %d', (a, b, expected) => {
  expect(a + b).toBe(expected);
});
```

#### `.test.concurrent(name, fn)`

Aliases: `.it.concurrent(name, fn)`

```js
each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
]).test.concurrent(
  'returns the result of adding %d to %d',
  (a, b, expected) => {
    expect(a + b).toBe(expected);
  },
);
```

#### `.test.concurrent.only(name, fn)`

Aliases: `.it.concurrent.only(name, fn)`

```js
each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
]).test.concurrent.only(
  'returns the result of adding %d to %d',
  (a, b, expected) => {
    expect(a + b).toBe(expected);
  },
);
```

#### `.test.concurrent.skip(name, fn)`

Aliases: `.it.concurrent.skip(name, fn)`

```js
each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
]).test.concurrent.skip(
  'returns the result of adding %d to %d',
  (a, b, expected) => {
    expect(a + b).toBe(expected);
  },
);
```

#### Asynchronous `.test(name, fn(done))`

Alias: `.it(name, fn(done))`

```js
each([['hello'], ['mr'], ['spy']]).test(
  'gives 007 secret message: %s',
  (str, done) => {
    const asynchronousSpy = message => {
      expect(message).toBe(str);
      done();
    };
    callSomeAsynchronousFunction(asynchronousSpy)(str);
  },
);
```

#### `.describe(name, fn)`

```js
each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
]).describe('.add(%d, %d)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });

  test('does not mutate first arg', () => {
    a + b;
    expect(a).toBe(a);
  });

  test('does not mutate second arg', () => {
    a + b;
    expect(b).toBe(b);
  });
});
```

#### `.describe.only(name, fn)`

Aliases: `.fdescribe(name, fn)`

```js
each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
]).describe.only('.add(%d, %d)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });
});
```

#### `.describe.skip(name, fn)`

Aliases: `.xdescribe(name, fn)`

```js
each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
]).describe.skip('.add(%d, %d)', (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });
});
```

---

## Tagged Template Literal of rows

### API

#### `each[tagged template].test(name, suiteFn)`

```js
each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`.test('returns $expected when adding $a to $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});
```

##### `each` takes a tagged template string with:

- First row of variable name column headings separated with `|`
- One or more subsequent ro^K)éaËşÿÌÌÌÌÌÌÌMœéˆà»ÿM°é€à»ÿMˆéxà»ÿ‹T$B‹J3ÈèW¦»ÿ¸P^K)é'ËşÿÌÌÌÌÌÌÌÌÌÌÌÌÌ|ÿÿÿéj½ÿhä  ‹EÌPè3ä»ÿƒÄÃ‹T$B‹J„3Èè¦»ÿ¸]K)éâÊşÿÌÌÌÌÌÌÌÌPÿÿÿéÕi½ÿ‹T$B‹ŠTÿÿÿ3Èèá¥»ÿ¸_K)é±ÊşÿÌÌÌÌÌÌÌ3Û‹EÀ¹$   ÷áÃ÷ÛØ3ÀƒÃ’À÷ØÃP‹EÔPè¤ÃşÿƒÄÃÿÿÿéˆä»ÿàşÿÿémi½ÿ,ÿÿÿé’ß»ÿ@ÿÿÿégä»ÿTÿÿÿéLŸ»ÿ‹T$B‹Šäşÿÿ3ÈèX¥»ÿ¸À^K)é(ÊşÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌŒşÿÿéi½ÿ‹T$B‹Š”şÿÿ3Èè!¥»ÿ‹Jü3Èè¥»ÿ¸„_K)éçÉşÿÌÌÌÌÌÌÌÌÌÌÌÌÌhæN)èBºşÿYÃ<ÿÿÿéÉh½ÿtÿÿÿéîŞ»ÿ‹T$B‹Š@ÿÿÿ3ÈèÊ¤»ÿ¸X_K)éšÉşÿÿÿÿéÅŞ»ÿ”şÿÿéŠh½ÿàşÿÿé¯Ş»ÿÌşÿÿé¤Ş»ÿøşÿÿéyã»ÿ‹T$B‹Š˜şÿÿ3Èèu¤»ÿ¸t^K)éEÉşÿÌÌÌÌÌÌÌÌÌÌÌM”éHã»ÿ‹T$B‹Jœ3ÈèG¤»ÿ¸`K)éÉşÿÌÌÌÌÌÌÌÌÌÌÌÌÌ4ÿÿÿé%h½ÿÌşÿÿéh½ÿ ÿÿÿéh½ÿ”şÿÿéäg½ÿhè  ‹EœPèâ»ÿƒÄÃhØ  ‹EPèğá»ÿƒÄÃ‹T$B‹Š˜şÿÿ3ÈèÌ£»ÿ¸¨_K)éœÈşÿÌÌMé˜g½ÿ‹T$B‹J˜3Èè§£»ÿ¸0`K)éwÈşÿÌÌÌÌÌÌÌÌÌÌÌÌÌhä  ‹EÜPèá»ÿƒÄÃ‹T$B‹JĞ3Èèm£»ÿ¸DaK)é=ÈşÿÌÌÌMÌéÈR¾ÿ‹T$B‹JÔ3ÈèG£»ÿ¸Ô`K)éÈşÿÌÌÌÌÌÌÌÌÌÌÌÌÌtÿÿÿé•R¾ÿ<ÿÿÿéúf½ÿhÜ  ‹E´Pèá»ÿƒÄÃhä  ‹E¬Pèá»ÿƒÄÃ‹T$B‹ŠDÿÿÿ3Èèâ¢»ÿ¸aK)é²ÇşÿÌÌÌÌÌÌÌÌM¤é8R¾ÿlÿÿÿéf½ÿ‹T$B‹Štÿÿÿ3Èè©¢»ÿ¸¨`K)éyÇşÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌMˆéhœ»ÿ$ÿÿÿé= ÏÿàşÿÿéRf½ÿHÿÿÿéGœ»ÿ‹T$B‹Šäşÿÿ3ÈèS¢»ÿ¸t`K)é#ÇşÿÌÌÌÌÌÌÌÌÌM€é¨Q¾ÿHÿÿÿéf½ÿM°éUe¾ÿÿÿÿéúe½ÿMœéá»ÿ‹T$B‹Šÿÿÿ3Èèş¡»ÿ¸haK)éÎÆşÿÌÌÌÌxÿÿÿéÅe½ÿ‹T$B‹J€3ÈèÔ¡»ÿ¸¼aK)é¤ÆşÿÌÌÌÌÌÌÌÌÌÌ‹MğéèÀÙÿ‹T$B‹Jø3Èè§¡»ÿ¸bK)éwÆşÿÌÌÌÌÌÌÌÌÌÌÌÌÌdÿÿÿé•Û»ÿxÿÿÿéŠÛ»ÿMŒé‚Û»ÿM ézÛ»ÿM´érÛ»ÿMÈéjÛ»ÿh | )jj…dÿÿÿPèöÛ»ÿÃşÿÿée½ÿ¼şÿÿée½ÿLşÿÿée½ÿ„şÿÿéød½ÿ‹T$B‹Šşÿÿ3Èè¡»ÿ‹Jü3Èèú »ÿ¸\dK)éÊÅşÿjD‹EğPèñŞ»ÿƒÄÃjD‹EèPèâŞ»ÿƒÄÃ‹T$B‹Jà3ÈèÁ »ÿ¸ğaK)é‘ÅşÿÌÌÌÌÌÌÌM”é˜ß»ÿMĞéÀÜ»ÿ‹T$B‹Štÿÿÿ3ÈèŒ »ÿ¸8dK)é\ÅşÿÌÌxÿÿÿé…Ú»ÿ‹T$B‹Š|ÿÿÿ3Èèa »ÿ¸ÀcK)é1ÅşÿÌÌÌÌÌÌÌMĞé˜<¿ÿMŒé d½ÿTÿÿÿéd½ÿ‹T$B‹Š\ÿÿÿ3Èè! »ÿ¸<cK)éñÄşÿÌÌÌÌÌÌÌ@ÿÿÿéõŞ»ÿMéíŞ»ÿ˜şÿÿéÒc½ÿ|ÿÿÿé×Ş»ÿMÀéÏŞ»ÿĞşÿÿé´c½ÿhÿÿÿé¹Ş»ÿÿÿÿéc½ÿTÿÿÿé£Ş»ÿ‹T$B‹Šœşÿÿ3ÈèŸŸ»ÿ¸¸bK)éoÄşÿÌÌÌÌÌM¨éhc½ÿ‹T$B‹J°3ÈèwŸ»ÿ¸”cK)éGÄşÿÌÌÌÌÌÌÌÌÌÌÌÌÌpÿÿÿé5c½ÿ8ÿÿÿé*c½ÿh”  ‹EÄPèHİ»ÿƒÄÃ‹T$B‹Š@ÿÿÿ3Èè$Ÿ»ÿ¸XbK)éôÃşÿÌÌÌÌÌÌÌÌÌÌ(ÿÿÿéåb½ÿh”  ‹EÀPèİ»ÿƒÄÃ`ÿÿÿéØİ»ÿ‹T$B‹Š0ÿÿÿ3ÈèÔ»ÿ¸”bK)é¤ÃşÿÌÌÌÌÌÌÌÌÌÌhä  ‹EØPè¾Ü»ÿƒÄÃ‹T$B‹JÄ3Èè»ÿ¸hcK)émÃşÿÌÌÌMÈéxİ»ÿMÜépİ»ÿxÿÿÿéeİ»ÿMŒé]İ»ÿ‹T$B‹Šhÿÿÿ3ÈèY»ÿ¸dK)é)ÃşÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌM€é(İ»ÿM”é İ»ÿ‹T$B‹J„3Èè»ÿ¸,eK)éïÂşÿÌÌÌÌÌôşÿÿéåa½ÿ`ÿÿÿéjM¾ÿ,ÿÿÿéïa½ÿj$‹EPèğÛ»ÿƒÄÃ‹T$B‹Šüşÿÿ3ÈèÌ»ÿ¸ødK)éœÂşÿÌÌ‹T$B‹J¼3Èè¯»ÿ¸hK)éÂşÿÌÌÌÌÌMĞéÚÿ‹T$B‹JØ3Èè‡»ÿ¸ÀhK)éWÂşÿÌÌÌÌÌÌÌÌÌÌÌÌÌMÔéèÚÿ‹T$B‹JÜ3ÈèW»ÿ¸”hK)é'ÂşÿÌÌÌÌÌÌÌÌÌÌÌÌÌMÜé¸Úÿ‹T$B‹Jä3Èè'»ÿ¸ìhK)é÷ÁşÿÌÌÌÌÌÌÌÌÌÌÌÌÌMàéÚÿ‹T$B‹Jè3Èè÷œ»ÿ¸hhK)éÇÁşÿÌÌÌÌÌÌÌÌÌÌÌÌÌMÜéØÚÿ‹T$B‹Jä3ÈèÇœ»ÿ¸<hK)é—ÁşÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹MğƒÁéõ8¿ÿ‹T$B‹Jø3Èè”œ»ÿ¸XeK)édÁşÿÌÌÌÌÌÌÌÌÌÌM´éÈ8¿ÿMœéğÚÿ‹T$B‹J 3Èè_œ»ÿ¸ fK)é/ÁşÿÌÌÌÌÌM¬é8Û»ÿ‹T$B‹J´3Èè7œ»ÿ¸gK)éÁşÿÌÌÌÌÌÌÌÌÌÌÌÌÌM¤éø_½ÿ‹T$B‹J¬3Èèœ»ÿ¸LfK)é×ÀşÿÌÌÌÌÌÌÌÌÌÌÌÌÌMÄé88¿ÿ‹T$B‹JÌ3Èè×›»ÿ¸¸gK)é§ÀşÿÌÌÌÌÌÌÌÌÌÌÌÌÌMé˜_½ÿMÈépa½ÿ‹T$B‹J˜3ÈèŸ›»ÿ¸ìeK)éoÀşÿÌÌÌÌÌ|ÿÿÿé…_½ÿDÿÿÿéZ_½ÿhè  ‹EÌPèxÙ»ÿƒÄÃ‹T$B‹ŠHÿÿÿ3ÈèT›»ÿ¸¼fK)é$ÀşÿÌÌÌÌÌÌÌÌÌÌM˜é_½ÿMĞé€7¿ÿ‹T$B‹J 3Èè›»ÿ¸HgK)éï¿şÿÌÌÌÌÌMÌéX7¿ÿMØéP7¿ÿ‹T$B‹JÔ3Èèïš»ÿ¸€fK)é¿¿şÿÌÌÌÌÌHÿÿÿéÕ^½ÿ|ÿÿÿéÊ^½ÿÿÿÿéŸ^½ÿhè  ‹EÌPè½Ø»ÿƒÄÃ‹T$B‹Šÿÿÿ3Èè™š»ÿ¸ŒgK)éi¿şÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌM¬éx^½ÿ‹T$B‹J´3Èègš»ÿ¸èfK)é7¿şÿÌÌÌÌÌÌÌÌÌÌÌÌÌM¤éèÚÿ‹T$B‹J 3Èè7š»ÿ¸¸eK)é¿şÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹MğéH=Úÿ‹T$B‹Jø3Èèš»ÿ¸´iK)é×¾şÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹Mğé=Úÿ‹MğƒÁHéÍØ»ÿ‹T$B‹Jø3ÈèÌ™»ÿ¸ôkK)éœ¾şÿÌÌ3Û‹Eä¹   ÷áÃ÷ÛØ3ÀƒÃ’À÷ØÃP‹EèPè”·şÿƒÄÃ‹T$B‹JÀ3Èè‚™»ÿ¸iK)éR¾şÿÌÌÌÌÌÌÌÌj‹E´Pèq×»ÿƒÄÃj‹E¬Pèb×»ÿƒÄÃ|ÿÿÿéWÓ»ÿ‹T$B‹J„3Èè6™»ÿ‹Jü3Èè,™»ÿ¸nK)éü½şÿÌÌj‹E¼Pè!×»ÿƒÄÃj‹E´Pè×»ÿƒÄÃxÿÿÿéÓ»ÿ‹T$B‹J€3Èèæ˜»ÿ‹Jü3ÈèÜ˜»ÿ¸ÌnK)é¬½şÿÌÌhä  ‹EìPèÎÖ»ÿƒÄÃ‹T$B‹Jè3Èè­˜»ÿ¸ŒjK)é}½şÿÌÌÌM éÈ[¾ÿ‹T$B‹J¨3Èè‡˜»ÿ¸TnK)éW½şÿÌÌÌÌÌÌÌÌÌÌÌÌÌh,æN)è²­şÿYÃ‹T$B‹Jà3ÈèS˜»ÿ¸(nK)é#½şÿÌÌÌÌÌÌÌÌÌM´é(×»ÿMÈé ×»ÿ‹T$B‹J¸3Èè˜»ÿ¸ oK)éï¼şÿÌÌÌÌÌhÈ  ‹EÌPèÖ»ÿƒÄÃMĞéÖ‘»ÿ‹T$B‹JÈ3Èèå—»ÿ‹Jü3ÈèÛ—»ÿ¸°mK)é«¼şÿÌdÿÿÿé¥[½ÿ‹T$B‹Šhÿÿÿ3Èè±—»ÿ¸|mK)é¼şÿÌÌÌÌÌÌÌhä  ‹E PèÕ»ÿƒÄÃğşÿÿéƒ[½